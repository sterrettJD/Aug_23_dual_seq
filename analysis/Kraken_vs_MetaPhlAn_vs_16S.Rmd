---
title: "MetaPhlAn vs Kraken vs 16S"
author: "John Sterrett"
date: "2023-10-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

pacman::p_load("qiime2R",
               "phyloseq",
               "tidyverse",
               "microshades",
               "cowplot")
```

# Load data
```{r}
s.pseq <- qiime2R::qza_to_phyloseq(features="../16s-data/tax_filtered_dual.qza",
                              taxonomy="../16s-data/taxonomy_dual.qza",
                              metadata="../16s-data/16S_meta.txt")

m <- data.table::fread("../seq.f0.0.r0.0.nonhost.humann/all_bugs_list.tsv",
                       data.table=F)
k <- data.table::fread("../seq.f0.0.r0.0.nonhost.kraken/Combined-taxonomy.tsv",
                       data.table=F)

metadata <- data.table::fread("../metadata.csv", data.table=F)
rownames(metadata) <- metadata$Sample
metadata$Sample <- NULL
```

# Clean data

## 16S
```{r}
s.taxonomy.table <- tax_table(s.pseq) %>% as.data.frame()
s.host <- s.taxonomy.table[s.taxonomy.table$Phylum=="Vertebrata",]
s.host <- s.host[!is.na(s.host$Phylum),]
s.host.otuname <- rownames(s.host)

s.pseq.taxa <- taxa_names(s.pseq)
s.pseq.taxa <- s.pseq.taxa[!(s.pseq.taxa %in% s.host.otuname)]
s.pseq.nohost <- prune_taxa(s.pseq.taxa, s.pseq)

```

## Bracken to phyloseq
```{r}
pseq_from_bracken <- function(k, as.relative=TRUE){
    k.tax.table <- k[c("domain", "phylum", "class", 
                       "order", "family", "genus", "species")]
    
    if(as.relative==T){
        rel.cols <- colnames(k)[grepl(x=colnames(k), pattern="_frac")]
        k.feature.table <- k[,rel.cols]
        colnames(k.feature.table) <- gsub(
            colnames(k.feature.table), 
            pattern=".bracken_frac", replacement="")
    } 
    else if (as.relative==F) {
        num.cols <- colnames(k)[grepl(x=colnames(k), pattern="_frac")]
        k.feature.table <- k[,num.cols]
        colnames(k.feature.table) <- gsub(
            colnames(k.feature.table), 
            pattern=".bracken_num", replacement="")
    }
    k.pseq <- phyloseq::phyloseq(phyloseq::otu_table(k.feature.table, 
                                                     taxa_are_rows=T),
                       phyloseq::tax_table(as.matrix(k.tax.table)))

    return(k.pseq)
}

# Kraken includes competitive mapping to human genome, so remove that from this plot
k.pseq <- pseq_from_bracken(k)
sample_data(k.pseq) <- sample_data(metadata)

k.taxonomy.table <- tax_table(k.pseq) %>% as.data.frame()
host <- k.taxonomy.table[k.taxonomy.table$phylum=="Chordata",]
host <- host[!is.na(host$phylum),]
host.otuname <- rownames(host)

k.pseq.taxa <- taxa_names(k.pseq)
k.pseq.taxa <- k.pseq.taxa[!(k.pseq.taxa == host.otuname)]
k.pseq.nohost <- prune_taxa(k.pseq.taxa, k.pseq)
```

## MetaPhlAn to phyloseq
```{r}
# grabs a certain level of taxonomic resolution from the metaphlan output
# defaults to the max level of resolution
filter_mphlan_by_taxonomy_level <- function(df, level="max"){
    tax.names <- rownames(df)
    levels.contained <- stringr::str_count(tax.names, "\\|")
    
    if (level=="max"){
        level <- max(levels.contained)
    }
    
    to.return <- df[levels.contained==level,]
    rownames(to.return) <- rownames(df)[levels.contained==level]
    return (to.return)
}


# Converts metaphlan formatted taxonomy names to a taxonomy table for phyloseq
# based on https://gist.github.com/lwaldron/512d1925a8102e921f05c5b25de7ec94
names_to_tax_table <- function(bugs){
    splitted <- strsplit(bugs, split="|", fixed=T)
    # create empty taxonomy matrix
    taxmat <- matrix(NA, 
                     ncol=max(sapply(splitted, length)), 
                     nrow=length(splitted))
    colnames(taxmat) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Strain")[1:ncol(taxmat)]
    
    # add split taxonomy to the matrix
    for (i in 1:nrow(taxmat)){
        tax.resolution <- length(splitted[[i]])
        taxmat[i, 1:tax.resolution] <- splitted[[i]]
    }
    # remove the p__, f__, etc to indicate level
    taxmat <- gsub("[a-z]__", "", taxmat)
    
    return(taxmat)
}


rownames(m) <- m$`#clade_name`
m <- m %>% 
    dplyr::select(-c(`#clade_name`,
               NCBI_tax_id,
               additional_species))

# just get the lowest tax level. We can collapse again later
bugslist <- filter_mphlan_by_taxonomy_level(m, level="max")

# replace NA with 0
bugslist[is.na(bugslist)] <- 0

# check that our data are relative abundance adding up to 100 still
hundreds <- rep(100, ncol(bugslist))
names(hundreds) <- colnames(bugslist)
if (isFALSE(all.equal(target=hundreds, 
                      current=colSums(bugslist, na.rm=T), 
                      tolerance=0.001))){
    print("Data are NOT relative abundances summing to 100! Please check what's going on.")
} else {
    print("Samples sum to 100 (or close enough).")
}

# create tax table
bugs <- rownames(bugslist)
taxonomy.table <- names_to_tax_table(bugs)
rownames(taxonomy.table) <- bugs

# create phyloseq object
m.pseq <- phyloseq(otu_table=otu_table(bugslist, taxa_are_rows=T),
                 tax_table=tax_table(taxonomy.table),
                 sample_data=sample_data(metadata)
                 )
```

# Microshades {.tabset}
```{r plotting_setup, echo=F}

make_microshades <- function(pseq, biggroup="Phylum", subgroup="Genus"){
        
    # prep the microshades colors
    mdf_prep <- prep_mdf(pseq, subgroup_level=subgroup)
    # sort the phylum names
    phylum_table <- tax_glom(pseq, taxrank=biggroup) %>% otu_table()
    phyla.otunames <- rownames(phylum_table)
    taxonomy.table <- tax_table(pseq) %>% as.data.frame()
    
    phylums <- taxonomy.table[phyla.otunames, biggroup]
    
    sorted_phylums <- phylums[order(rowSums(phylum_table), decreasing=T)]
    # create the colors object
    color_objs_GP <- create_color_dfs(mdf_prep, 
                                      group_level=biggroup,
                                      subgroup_level=subgroup,
                                      selected_groups=sorted_phylums[5:1],
                                      cvd=TRUE)
    # Extract
    mdf_GP <- color_objs_GP$mdf
    cdf_GP <- color_objs_GP$cdf
    
    
    
    # create a custom legend
    GP_legend <-custom_legend(mdf_GP, cdf_GP,
                              group_level=biggroup,
                              subgroup_level=subgroup,
                              legend_key_size=unit(0.4, "cm"),
                              legend_text_size=10)
    
    # plot
    plot <- plot_microshades(mdf_GP, cdf_GP)
    plot_1 <- plot + scale_y_continuous(labels = scales::percent, expand = expansion(0)) +
      theme(legend.position = "none")  +
      theme(axis.text.x = element_text(size= 7),
            panel.background = element_rect(fill='transparent'), #transparent panel bg
            plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg
            panel.grid.major = element_blank(), #remove major gridlines
            panel.grid.minor = element_blank() #remove minor gridlines
            ) #transparent legend panel
    
    multi <- plot_grid(plot_1, GP_legend,  rel_widths = c(1, .25))
    return(multi)
}
```

## 16S
```{r 16s_phy_genus_microshades, fig.width=8, fig.height=10}
make_microshades(s.pseq.nohost)
```

## Kraken
```{r kraken_phy_genus_microshades, fig.width=8, fig.height=10}
make_microshades(k.pseq.nohost, biggroup="phylum", subgroup="genus")
```

## MetaPhlAn
```{r metaphlan_phy_genus_microshades, fig.width=8, fig.height=10}
make_microshades(m.pseq, biggroup="Phylum", subgroup="Genus")
```