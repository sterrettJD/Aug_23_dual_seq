---
title: "WGCNA"
author: "John Sterrett"
date: "2024-04-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# These are required for WGCNA but the standard CRAN install.packages doesn't 
# install them when installing WGCNA because they are bioc
bioc.deps <- c("impute", "GO.db", "preprocessCore")
for(package in bioc.deps){
    if(!require(package, character.only=T, quietly=T)){
        BiocManager::install(package)
    }    
}

pacman::p_load("tidyverse",
               "ggplot2",
               "WGCNA")
```

# Read and clean data
```{r}
# microbe KOs
gf.ko <- data.table::fread("../seq.f0.0.r0.0.nonhost.humann/all_genefamilies_ko_named.tsv",
                        data.table=F)

rownames(gf.ko) <- gf.ko$`# Gene Family`
gf.ko$`# Gene Family` <- NULL
gf.ko <- gf.ko %>% mutate_all(as.numeric)
colnames(gf.ko) <- colnames(gf.ko) %>% 
    gsub(pattern="_Abundance-RPKs", replacement="")

gf.ko.tax.rows <- rownames(gf.ko) %>% grepl(pattern="\\|")
gf.ko.notax <- gf.ko[!gf.ko.tax.rows,]
gf.ko.tax <- gf.ko[gf.ko.tax.rows,]


# Host genes
gn <- data.table::fread("../seq.f0.0.r0.0.host/counts.txt", data.table=F)
colnames(gn) <- colnames(gn) %>% gsub(pattern="seq.f0.0.r0.0.host/",
                                      replacement="")
colnames(gn) <- colnames(gn) %>% gsub(pattern=".bam",
                                      replacement="")
rownames(gn) <- gn$Geneid
gn$Geneid <- NULL

gns.only <- gn[!colnames(gn) %in% c("Chr", "Start", "End", "Strand", "Length")] %>%
    as.matrix()

# Metadata
metadata <- data.table::fread("../16s-data/16S_meta.txt",
                        data.table=F)

# Samples before DM 33 were stored in PBS, all others (including LG)
is.DM <- grepl("DM", metadata$Sample_ID)
number <- str_split(metadata$Sample_ID, pattern="_") %>% 
    lapply(function(x){x[2]}) %>% 
    unlist() %>% 
    as.numeric()

metadata$storage_method <- rep(NA, nrow(metadata)) %>% as.character()
metadata[((number < 33) & (is.DM)), "storage_method"] <- "PBS"
metadata[is.na(metadata$storage_method), "storage_method"] <- "RNALater"

metadata[is.DM, "Participant"] <- paste0("DM_", number[is.DM])
metadata[!is.DM, "Participant"] <- paste0("LG_", number[!is.DM])

metadata %>% 
    group_by(Participant) %>% 
    summarise(MSM=dplyr::first(MSM)) %>%
    select(MSM) %>%
    as.data.frame() %>%
    mutate(MSM=as.factor(MSM)) %>%
    summary()

get_timepoint <- function(sampleIDs) {
  split_strings <- str_split(sampleIDs, "_")
  # LG samples don't have a timepoint, so we'll just fill in "1" for them
  timepoints <- sapply(split_strings, function(x) {
    if (length(x) >= 3) {
      return(as.numeric(x[3]))
    } else {
      return(1)
    }
  })
  return(timepoints)
}

metadata$timepoint <- get_timepoint(metadata$Sample_ID)


```

# Subset data to create fully non-longitudinal dataset
```{r}
subset.metadata <- metadata %>% filter(storage_method=="RNALater",
                                       timepoint==1)
gf.ko.notax.subset <- gf.ko.notax[,subset.metadata$Sample_ID]

gns.only.subset <- gns.only[,subset.metadata$Sample_ID]

```

# Preprocess
## Host
```{r}
# Filter transcripts with fewer than 50 total reads across the dataset
gns.only.subset <- gns.only.subset[rowSums(gns.only.subset) > 50,]
# read into DESeq2 for normalization
ds.dat <- DESeq2::DESeqDataSetFromMatrix(gns.only.subset,
                               colData=subset.metadata,
                               design=~1)
dds <- DESeq2::DESeq(ds.dat)
# Normalize data
vsd <- DESeq2::getVarianceStabilizedData(dds)

# remove any genes below the 25th percentile of variance
rv_vsd <- matrixStats::rowVars(vsd)
summary(rv_vsd)
q25_vsd <- quantile(rv_vsd, .25)
gns.only.subset.normalized <- vsd[rv_vsd > q25_vsd, ]
print(paste("Host transcripts after filtering:", nrow(gns.only.subset.normalized)))
```

## Microbes

```{r}
# apply a TSS normalization (this is transcripts per million)
gf.ko.notax.subset.rel <- t(t(gf.ko.notax.subset)/colSums(gf.ko.notax.subset))
tol <- 1e-4
if(any(colSums(gf.ko.notax.subset.rel) < 1-tol | 
       colSums(gf.ko.notax.subset.rel) > 1+tol)){
    stop("Microbial KOs are not in relative abundances.")
}
# Filter transcripts seen less than 1 per 100000 transcripts
threshold.microbe.genes <- ncol(gf.ko.notax.subset.rel)*1e-6
gf.ko.notax.subset.rel.f <- gf.ko.notax.subset.rel[rowSums(gf.ko.notax.subset.rel) > threshold.microbe.genes,]

rv_gf.ko.notax.subset.rel.f <- matrixStats::rowVars(gf.ko.notax.subset.rel.f)
summary(rv_gf.ko.notax.subset.rel.f)
q25_rv_gf.ko.notax.subset.rel.f <- quantile(rv_gf.ko.notax.subset.rel.f, .25)
gf.ko.notax.subset.rel.f <- gf.ko.notax.subset.rel.f[rv_gf.ko.notax.subset.rel.f > q25_rv_gf.ko.notax.subset.rel.f, ]
print(paste("Microbial KOs after filtering:", nrow(gf.ko.notax.subset.rel.f)))
```


# WGCNA setup
```{r}
n.threads <- 4
allowWGCNAThreads(n.threads)

# ~16 GB RAM, per Langfelder's blog
# https://peterlangfelder.com/2018/11/25/blockwise-network-analysis-of-large-data/
max.block.size <- 20000
```

# WGCNA on host
```{r}
# Choose a set of soft-thresholding powers
powers <- c(c(1:10), seq(from = 12, to = 20, by = 2))

# Call the network topology analysis function
sft <- pickSoftThreshold(
  t(gns.only.subset.normalized),
  blockSize = max.block.size,
  powerVector = powers,
  verbose = 5
)

sft_df <- data.frame(sft$fitIndices) %>%
  dplyr::mutate(model_fit = -sign(slope) * SFT.R.sq)

ggplot(sft_df, aes(x=Power, y=model_fit, label=Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  # Plot the WGCNA recommended R^2 cutoff
  geom_hline(yintercept = 0.80, col = "red") +
  ylim(c(min(sft_df$model_fit), 1.05)) +
  xlab("Soft Threshold (power)") +
  ylab("Scale Free Topology Model Fit, signed R^2") +
  theme_bw()

chosen.power <- 20

bwnet <- blockwiseModules(t(gns.only.subset.normalized),
  maxBlockSize=max.block.size,
  TOMType="signed",
  power=chosen.power, # soft threshold for network construction
  numericLabels=TRUE, # Use numbers instead of colors for module labels
  randomSeed=1234
)
readr::write_rds(bwnet,
  file = file.path("host_wgcna_results.RDS")
)



mergedColors <- labels2colors(bwnet$colors)

plotDendroAndColors(
  bwnet$dendrograms[[1]],
  mergedColors[bwnet$blockGenes[[1]]],
  "Module colors",
  dendroLabels=FALSE,
  hang=0.03,
  addGuide=TRUE,
  guideHang=0.05 )

plotEigengeneNetworks(bwnet$MEs, "Eigengene Adjacency Heatmap", marHeatmap = c(3,4,2,2))
```

# WGCNA on microbes
```{r}
extra.powers <- c(powers, seq(22, 50, by=2))

# Call the network topology analysis function
sft <- pickSoftThreshold(
  t(gf.ko.notax.subset.rel.f),
  blockSize=max.block.size,
  powerVector=extra.powers,
  verbose=5
)

sft_df <- data.frame(sft$fitIndices) %>%
  dplyr::mutate(model_fit = -sign(slope) * SFT.R.sq)

ggplot(sft_df, aes(x=Power, y=model_fit, label=Power)) +
  geom_point() +
  geom_text(nudge_y = 0.1) +
  # Plot the WGCNA recommended R^2 cutoff
  geom_hline(yintercept = 0.80, col = "red") +
  ylim(c(min(sft_df$model_fit), 1.05)) +
  xlab("Soft Threshold (power)") +
  ylab("Scale Free Topology Model Fit, signed R^2") +
  theme_bw()

chosen.power <- 30

bwnet.microbes <- blockwiseModules(t(gf.ko.notax.subset.rel.f),
  maxBlockSize=max.block.size,
  TOMType="signed",
  power=chosen.power, # soft threshold for network construction
  numericLabels=TRUE, # Use numbers instead of colors for module labels
  randomSeed=1234
)

readr::write_rds(bwnet.microbes,
  file = file.path("microbes_wgcna_results.RDS")
)


mergedColors <- labels2colors(bwnet.microbes$colors)

plotDendroAndColors(
  bwnet.microbes$dendrograms[[1]],
  mergedColors[bwnet.microbes$blockGenes[[1]]],
  "Module colors",
  dendroLabels=FALSE,
  hang=0.03,
  addGuide=TRUE,
  guideHang=0.05)

plotEigengeneNetworks(bwnet.microbes$MEs, "Eigengene Adjacency Heatmap", marHeatmap = c(3,4,2,2))
```


# SCNIC on microbes
```{r}


```


# Associations between host modules and microbes modules
## WGCNA-WGCNA
## WGCNA-SCNIC



# WGCNA on all

